========================================================================
                          复杂度分析
========================================================================

注意：
- 你的时间复杂度以大O符号表示。
- 对于涉及单个集合的操作，复杂度以n表示，其中n是集合中的元素数量。
- 对于涉及两个集合的操作，复杂度以n和m表示，其中n和m分别是两个集合中的元素数量。

--------
集合并集（SetUnion）
--------

最坏情况复杂度：O(n + m)

解释：该函数遍历两个集合以合并它们的元素。
每个集合都会被完全遍历，因此总的复杂度是O(n + m)。

---------------
集合交集（SetIntersection）
---------------

最坏情况复杂度：O(n + m)

解释：该函数遍历两个集合中的元素以查找公共元素。
复杂度是O(n + m)。

-------------
集合差集（SetDifference）
-------------

最坏情况复杂度：O(n + m)

解释：该函数遍历第一个集合的元素，并检查它们是否不存在于第二个集合中。
复杂度是O(n + m)。

---------
集合是否相等（SetEquals）
---------

最坏情况复杂度：O(n + m)

解释：该函数使用集合并集和集合差集操作，
这两者的复杂度都是O(n + m)。结合后的逻辑确保总复杂度保持在O(n + m)。

---------
集合子集（SetSubset）
---------

最坏情况复杂度：O(n + m)

解释：该函数通过遍历两个集合来判断一个集合是否是另一个集合的子集。
复杂度是O(n + m)。

--------
集合下界（SetFloor）
--------

最坏情况复杂度：O(log n)

解释：该函数使用AVL树查找小于或等于给定值的最大元素。搜索的复杂度是O(log n)。

----------
集合上界（SetCeiling）
----------

最坏情况复杂度：O(log n)

解释：与SetFloor类似，该函数使用AVL树查找大于或等于给定值的最小元素。复杂度是O(log n)。

========================================================================
               游标操作设计文档
========================================================================

游标操作允许按照排序顺序顺序遍历集合元素。

设计与实现：
- 游标实现为一个栈，用于在AVL树的中序遍历过程中存储节点。
- SetCursorNew：初始化游标，并将最左侧的节点推送到栈中。
- SetCursorNext：从栈中弹出顶部节点，处理它，并在其右子树节点存在时将其推送到栈中。
- 这些操作确保了遍历的高效性，SetCursorNext的时间复杂度为O(1)（对于每个元素），而初始化的时间复杂度为O(h)，其中h是AVL树的高度。

========================================================================
